// /api/whatsapp-webhook.js
// EUROCAM: respuestas por palabra clave + soporte para botones (quick replies)
// + LOG de STATUSES (entregado/le√≠do/errores) para diagnosticar env√≠os

const VERIFY_TOKEN = process.env.VERIFY_TOKEN || "eurocam123";
const WHATSAPP_TOKEN = process.env.WHATSAPP_TOKEN;             // token largo de Meta
const PHONE_NUMBER_ID = process.env.WABA_PHONE_NUMBER_ID;      // p.ej. "869388702920570"
const TEMPLATE_NAME = process.env.TEMPLATE_NAME_AUTOREPLY || "respuesta_automatica_eurocam";
const TEMPLATE_LANG = process.env.TEMPLATE_LANG_CODE || "es";  // usa "es" si tu plantilla no tiene es_AR

const WABA_URL = (id) => `https://graph.facebook.com/v20.0/${id}/messages`;

// ---------- util ----------
function tsToISO(ts) {
  // Meta manda epoch (seg) en statuses[].timestamp
  if (!ts) return "";
  const n = Number(ts) * 1000;
  if (Number.isNaN(n)) return String(ts);
  return new Date(n).toISOString();
}

async function postWABA(payload) {
  const res = await fetch(WABA_URL(PHONE_NUMBER_ID), {
    method: "POST",
    headers: {
      Authorization: `Bearer ${WHATSAPP_TOKEN}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify(payload),
  });
  const text = await res.text();
  if (!res.ok) {
    console.error("‚ùå WABA ERROR:", res.status, text);
  } else {
    console.log("‚úÖ WABA OK:", res.status, text);
  }
  return res.ok;
}

async function sendText(to, body) {
  return postWABA({
    messaging_product: "whatsapp",
    to,
    type: "text",
    text: { body },
  });
}

async function sendTemplate(to) {
  // Envi√° la plantilla si ya est√° APROBADA (sino va a fallar)
  return postWABA({
    messaging_product: "whatsapp",
    to,
    type: "template",
    template: {
      name: TEMPLATE_NAME,
      language: { code: TEMPLATE_LANG }, // "es" √≥ "es_AR" seg√∫n tu plantilla
    },
  });
}

// Extrae selecci√≥n de bot√≥n (plantillas quick-reply o mensajes interactivos)
function pickButton(msg) {
  // Plantilla quick reply
  if (msg?.button?.text) return (msg.button.text || "").toLowerCase();
  // Interactivo
  const br = msg?.interactive?.button_reply;
  if (br?.text) return (br.text || "").toLowerCase();
  if (br?.id) return (br.id || "").toLowerCase();
  return null;
}

// Respuesta por palabra clave (ventas/administraci√≥n) para EUROCAM
function buildAutoReply(messageText) {
  const t = (messageText || "")
    .normalize("NFD")
    .replace(/\p{Diacritic}/gu, "")
    .toLowerCase();

  const ventas =
    "üìç *Sucursales de Ventas - EUROCAM*\n" +
    "üè¢ Mataderos: +54 9 11 7361-4719\n" +
    "üè¢ Canning:   +54 9 11 7063-5836";

  const admin =
    "üíº *Administraci√≥n - EUROCAM*\n" +
    "+54 9 11 2264-5064";

  const generic =
    "üëã Hola, este n√∫mero es el canal automatizado de *EUROCAM*.\n" +
    "Escrib√≠ o eleg√≠ una opci√≥n:\n" +
    "‚Ä¢ *Ventas*\n" +
    "‚Ä¢ *Administraci√≥n*";

  if (t.includes("venta")) return ventas; // cubre "venta" y "ventas"
  if (t.includes("administracion")) return admin; // cubre con/sin tilde

  return generic;
}

// ---------- NUEVO: log de statuses ----------
function logStatuses(statuses) {
  try {
    for (const s of statuses || []) {
      const {
        id,                // id del mensaje original
        status,            // delivered, read, failed, sent, etc.
        timestamp,         // epoch seg
        recipient_id,      // destinatario (waid)
        conversation,      // info de conversaci√≥n/plantilla
        pricing,           // info de cobro
        errors,            // array con objetos de error (si failed)
      } = s || {};

      const iso = tsToISO(timestamp);

      if (status === "failed") {
        console.error("üõë STATUS FAILED", {
          id, status, iso, recipient_id, conversation, pricing, errors,
        });
      } else {
        console.log("üì¨ STATUS", {
          id, status, iso, recipient_id, conversation, pricing,
        });
      }
    }
  } catch (e) {
    console.error("Error al registrar statuses:", e);
  }
}

export default async function handler(req, res) {
  try {
    // Verificaci√≥n de Meta (GET)
    if (req.method === "GET") {
      const mode = req.query["hub.mode"];
      const token = req.query["hub.verify_token"];
      const challenge = req.query["hub.challenge"];
      if (mode === "subscribe" && token === VERIFY_TOKEN) {
        return res.status(200).send(challenge);
      }
      return res.status(403).send("Error de verificaci√≥n");
    }

    // Mensajes / estados entrantes (POST)
    if (req.method === "POST") {
      const body = req.body || {};
      const value = body?.entry?.[0]?.changes?.[0]?.value;

      // 0) LOG DE STATUSES (NO LOS IGNORAMOS M√ÅS)
      if (value?.statuses) {
        logStatuses(value.statuses);
        return res.status(200).end();
      }

      // 1) Mensajes
      const msg = value?.messages?.[0];
      const from = msg?.from;
      if (!from || !msg) return res.status(200).end();

      console.log("üì© Mensaje recibido de", from, ":", msg?.text?.body || "(no-text)");

      // 1.1) Bot√≥n ‚Üí tratamos como palabra clave
      const buttonChoice = pickButton(msg);
      if (buttonChoice) {
        const reply = buildAutoReply(buttonChoice);
        await sendText(from, reply);
        return res.status(200).end();
      }

      // 1.2) Texto ‚Üí palabra clave
      const text = (msg?.text?.body || "").toString();
      if (text) {
        const reply = buildAutoReply(text);
        // Si respondi√≥ gen√©rico, intentamos plantilla (si est√° aprobada)
        if (reply.includes("canal automatizado")) {
          const ok = await sendTemplate(from);
          if (!ok) await sendText(from, reply); // fallback si la plantilla a√∫n est√° en revisi√≥n
        } else {
          await sendText(from, reply);
        }
        return res.status(200).end();
      }

      // 1.3) Sin texto/bot√≥n (ej. medios) ‚Üí ayuda gen√©rica
      const ok = await sendTemplate(from);
      if (!ok) {
        await sendText(
          from,
          "üëã Hola, este n√∫mero es el canal automatizado de *EUROCAM*.\n" +
            "Escrib√≠ *Ventas* o *Administraci√≥n* para continuar."
        );
      }
      return res.status(200).end();
    }

    return res.status(404).send("Not found");
  } catch (e) {
    console.error("üí• Error en webhook:", e?.response?.data || e?.message || e);
    // Meta exige 200 para no reintentar en loop
    return res.status(200).end();
  }
}

// Para que Vercel parsee JSON de la request
export const config = { api: { bodyParser: true } };

